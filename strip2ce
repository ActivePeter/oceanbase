#!/usr/bin/python
# coding=utf8
'''
# name: strip2ce
# author: 千三
# doc: https: https://yuque.antfin.com/docs/share/a24792b6-95f7-4a44-89cb-dd5f9bc59a58?#
'''
import os
import sys
import getopt
import threading
import datetime
import time
import subprocess
import signal
import uuid
import re
import shutil
import json
import socket
from copy import copy

reload(sys)
sys.setdefaultencoding('utf8')

# 全局停止标志
GLBOAL_STOP_FLAG = False
# 全局日志锁，避免日志串行
GLOBAL_PRINT_LOCK = threading.Lock()
# 统计开始时间
GLOBAL_START_TIME = datetime.datetime.now()

# 所有源码文件
all_source_files = []

# 所有删除的文件
source_del_files = []
# cmake 要删除的文件
cmake_del_files = []
# 空文件
empty_del_files = []

# 检查模式下使用
all_need_cpp_file_list = []
# 原来是空文件夹记录，用于对比裁剪之后是文件夹情况
ori_empty_dir_list = []

# 进度信息
GLBOAL_PROCESS_LOCK = threading.Lock()
GLOBAL_CUR_COUNT = 0
GLOBAL_ALL_COUNT = 0

final_result = dict()

class ERROR_CODE():
    '''
    错误码
    '''
    # 通用成功和失败
    COMMON_SUCCESS = 0
    COMMON_ERROR = 1

    BAD_FILE = 2

    # 脚本内部错误
    SCRIPT_INTERNAL_ERROR = 21

class SOURCE_RANGE():
    '''
    源码范围
    '''
    COMMON = "COMMON"
    OPENSOURCE = "OPENSO"
    BUSINESS = "BUSINE"
    BORDER = "BORDER"

class RUN_MODE():
    '''
    运行模式
    '''
    STRIP_MODE = "裁剪模式"
    CHECK_MODE = "检查模式"
    SOURCE_DEBUG_MODE = "单个文件调试模式"

class TEXT_STRIP_TYPE():
    '''
    核心文本裁剪模式
    '''
    NOTE_MODE = "note类型裁剪"
    CMAKE_MODE = "cmake类型裁剪"
    CPP_MODE = "cpp类型裁剪"

class GlobalConf():
    '''
    编译配置类
    '''
    def __init__(self):
        # 基础信息
        self.tool_bin = "strip2ce"
        self.tool_name = "strip2ce OB开源代码裁剪工具"
        # 版本号
        self.version = "1.1 Beta"
        # 构建日志
        self.buildtime = "20221010"

        # 帮助链接
        self.help_link = "https://yuque.antfin.com/docs/share/a24792b6-95f7-4a44-89cb-dd5f9bc59a58?#"
        self.auther = "千三"

        # 当前运行模式
        self.run_mode = RUN_MODE.STRIP_MODE

        # 调试类型
        self.debug_source = ""
        self.debug_type = ""
        self.nosave = False

        # 输入的traceid
        self.traceid = "%s" % uuid.uuid1()

        # 后端请求地址
        self.api_url = "http://ob-make.oceanbase-dev.com:8000/obbuild/api/v1"

        # 工作目录文件
        self.git_top_dir = ""

        # 并发数
        self.jobs = 32
        # 并发控制
        self.semaphore = threading.Semaphore(self.jobs)

        # 是否开启调试
        self.enable_debug = False

        # 总共步骤数量
        self.total_step_count = 8
        # 当前步骤数量
        self.cuurent_step_count = 0

        # 常见后缀
        self.cmake_type_suffix = ("CMakeLists.txt", ".cmake")
        self.cpp_type_suffix = (".c", ".cc", ".ipp", ".hpp", ".cpp", ".cxx", ".h", ".h.in", ".cpp.in", ".hxx", ".lxx")
        self.note_type_suffix = ("CMakeLists.txt", ".cmake", ".c", ".cc", ".ipp", ".hpp", ".cpp", ".cxx", ".h", ".h.in", ".cpp.in", ".hxx", ".lxx", ".sh", ".bash", ".deps", ".opensource", "hotfuncs.txt", ".py", ".y", ".l", ".map", "ld.lds")
        # 忽略后缀
        self.ignore_suffix = (".git", ".dep_create", "build_", "deps/3rd", ".ccls-cache")

GLOBAL_CONF = GlobalConf()

def touch_dir(target_file):
    '''
    根据目录或者文件名字，创建目录
    '''
    true_target_dir = target_file
    if not os.path.isdir(target_file):
        true_target_dir = os.path.dirname(target_file)

    if os.path.exists(true_target_dir):
        # 已经存在就不再创建
        return
    os.makedirs(true_target_dir)

def write_json_file(file_path, json_dict):
    '''
    写入json文件
    '''
    result = dict()
    result['return_code'] = ERROR_CODE.COMMON_ERROR
    result['return_message'] = ""

    try:
        with open(file_path, 'w') as fd:
            fd.writelines(json.dumps(json_dict))
    except BaseException as ex:
        print_log(ex)
        result['return_code'] = ERROR_CODE.BAD_FILE
        result['return_message'] = "%s 写入json失败, err:%s" % (file_path, ex)
        return result

    result['return_code'] = ERROR_CODE.COMMON_SUCCESS
    result['return_message'] = "ok"
    return result

def shell_run_command(command_str, need_print_all=True, need_print_output=True, no_time=False):
    '''
    运行shell命令
    '''
    if need_print_all:
        print_log("[运行命令]: %s" % command_str)
        if not need_print_output:
            print_log("[运行输出]: 日志过多已经忽略输出")
    result = dict()
    result["return_code"] = 1
    result["return_message"] = []
    is_frist = False
    ps = subprocess.Popen(command_str,
                          stdin=subprocess.PIPE,
                          stdout=subprocess.PIPE,
                          stderr=subprocess.STDOUT,
                          shell=True,
                          close_fds=True)
    while True:
        data = ps.stdout.readline()
        if data == b'':
            if ps.poll() is not None:
                break
        result["return_message"].append(data)

        if not need_print_all:
            continue

        if need_print_output and len(data.strip()) > 1:
            if not is_frist:
                print_log("[运行输出]: %s" % data.replace("\n", ""))
                is_frist = True
            else:
                data_str = "            %s" % data.replace("\n", "")
                if no_time:
                    print(data_str)
                else:
                    print_log("            %s" % data.replace("\n", ""))

    result["return_code"] = ps.returncode
    return result

def ctrl_c_handler(signum, frame):
    '''
    处理ctrl+c信号
    '''
    global GLBOAL_STOP_FLAG
    if GLBOAL_STOP_FLAG:
        print("正在退出，请稍等...")
        return

    print("\n\n手动终止停止，正在平滑退出，请稍等...")
    GLBOAL_STOP_FLAG = True

    sys.stdout.flush()
    exit(ERROR_CODE.COMMON_ERROR)

def div_operator(num1, num2):
    '''
    除法运算,方便除0
    '''
    if num2 == 0:
        return 0

    return 1.0 * num1 / num2

def get_cost_time():
    '''
    获取当前运行时间
    '''
    global GLOBAL_START_TIME
    cost_time_sec = (datetime.datetime.now() - GLOBAL_START_TIME).seconds
    return "%dm%.2ds" % (cost_time_sec / 60, cost_time_sec % 60)

def get_cost_time_ms():
    '''
    获取毫秒时间
    '''
    global GLOBAL_START_TIME
    return (datetime.datetime.now() - GLOBAL_START_TIME).seconds * 1000

def print_log(log_str):
    '''
    打印日志函数
    '''
    global GLOBAL_PRINT_LOCK
    global GLBOAL_STOP_FLAG
    GLOBAL_PRINT_LOCK.acquire()
    if not GLBOAL_STOP_FLAG:
        print("[%s %s] %s" % (time.strftime("%m-%d %H:%M:%S", time.localtime()), get_cost_time(), log_str))
        sys.stdout.flush()
    GLOBAL_PRINT_LOCK.release()

def print_new_line():
    '''
    打印新一行
    '''
    print_log("")

def print_link_url():
    '''
    打印帮助信息
    '''
    print_new_line()
    print_log("问题咨询: %s" % GLOBAL_CONF.auther)
    print_log("帮助文档: %s" % ((GLOBAL_CONF.help_link)))

def print_help():
    '''
    打印帮助信息
    '''
    print("Usage: %s [optional arg], default in STRIP_MODE" % (GLOBAL_CONF.tool_bin))
    print("Options:")
    print("\t-h, --help                 print this message and exit")
    print("\t-v, --version              print the version number and exit")
    print("\t--check                    run in CHECK_MODE")
    print("\t-s, --source               run in SOURCE_DEBUG_MODE")
    print("\t-t, --type                 debug type, support cpp, cmake, note, no input will by suffix")
    print("\t--nosave                   no save file for CHECK_MODE and SOURCE_DEBUG_MODE")

    print("Exeamle:")
    print("\t ./%s" % GLOBAL_CONF.tool_bin)
    print("\t ./%s --check" % GLOBAL_CONF.tool_bin)
    print("\t ./%s -s src/observer/main.cpp" % GLOBAL_CONF.tool_bin)
    print("\t ./%s -s src/observer/main.cpp -t note" % GLOBAL_CONF.tool_bin)

    print_new_line()
    print("关键中文说明:")
    print("\t1. %s是OB开源代码裁剪工具，通过该命令可以将内外一套代码裁剪成纯开源代码" % (GLOBAL_CONF.tool_bin))
    print("\t2. %s支持三种模式，默认是[%s]，还支持[%s]和[%s]" % (GLOBAL_CONF.tool_bin, RUN_MODE.STRIP_MODE, RUN_MODE.CHECK_MODE, RUN_MODE.SOURCE_DEBUG_MODE))
    print("\t3. [%s]将检查裁剪之后，编译所需要的所有文件是否存在，只有都在才是一个合理的裁剪" % (RUN_MODE.CHECK_MODE))
    print("\t4. [%s]可以单独调试某一个裁剪文本的情况，默认会根据后缀进行判断，也可以通过-t强行指定类型" % (RUN_MODE.SOURCE_DEBUG_MODE))

    print_link_url()

def print_bar():
    '''
    打印欢迎内容
    '''
    print(
        """
            __           **           ___
    _____  / /_  _____  __  ____     |__ \    _____  ___
   / ___/ / __/ / ___/ / / / __ \    __/ /   / ___/ / _ \\
  (__  ) / /_  / /    / / / /_/ /   / __/   / /__  /  __/
 /____/  \__/ /_/    /_/ / ____/   /____/   \___/  \___/
                        /_/
""")

def get_flag(cmd, str_prefix):
    '''
    获得编译参数 例如获取 -c后面一个参数
    '''
    if " %s " % str_prefix not in cmd:
        return ""
    command_list = cmd.split(" ")
    for i in range(len(command_list)):
        if command_list[i].strip() == str_prefix:
            if i + 1 < len(command_list):
                return command_list[i + 1].strip()
    return ""

def parse_arg():
    '''
    解析命令行参数
    '''
    global GLOBAL_CONF

    try:
        # sys.argv[1:] 过滤掉第一个参数(它是脚本名称，不是参数的一部分)
        opts, args = getopt.getopt(sys.argv[1:], "hvs:t:", ["help", "version", "source=", "type=", "check", "nosave"])

        if args:
            print_log("不符合预期输入，请重试\n")
            print_help()
            exit(ERROR_CODE.COMMON_ERROR)

        for cmd, arg in opts:
            if cmd in ("-h", "--help"):
                print_help()
                exit(ERROR_CODE.COMMON_SUCCESS)
            elif cmd in ("-v", "--version"):
                print_log("version %s (build%s)\n" % (GLOBAL_CONF.version, GLOBAL_CONF.buildtime))
                print_link_url()
                exit(ERROR_CODE.COMMON_SUCCESS)
            elif cmd in ("-s", "--source"):
                GLOBAL_CONF.run_mode = RUN_MODE.SOURCE_DEBUG_MODE
                GLOBAL_CONF.debug_source = arg.strip()
            elif cmd in("-t", "--type"):
                if arg == "cpp":
                    GLOBAL_CONF.debug_type = TEXT_STRIP_TYPE.CPP_MODE
                elif arg == "cmake":
                    GLOBAL_CONF.debug_type = TEXT_STRIP_TYPE.CMAKE_MODE
                elif arg == "note":
                    GLOBAL_CONF.debug_type = TEXT_STRIP_TYPE.NOTE_MODE
                else:
                    print_log("未知调试类型输入[%s], 仅支持 cpp, cmake 和 note" % (arg))
                    exit(ERROR_CODE.COMMON_ERROR)
            elif cmd in ("--check"):
                GLOBAL_CONF.run_mode = RUN_MODE.CHECK_MODE
            elif cmd in ("--nosave"):
                GLOBAL_CONF.nosave = True

    except getopt.GetoptError as ex:
        print_log("getopt.GetoptError 解析参数失败，请合法输入, %s" % ex)
        print_link_url()
        exit(ERROR_CODE.COMMON_ERROR)
    except ValueError as ex:
        print_log("ValueError 解析参数失败，请合法输入, %s" % ex)
        print_link_url()
        exit(ERROR_CODE.COMMON_ERROR)

def handle_one_cmake_file(cmake_src, cmake_opensource_src = None):
    '''
    处理cmake文件
    '''
    lines = None
    with open(cmake_src, "r") as fd:
        lines = fd.readlines()

    if not cmake_opensource_src:
        cmake_opensource_src = cmake_src

    line_dict_list = []
    # 本次算法都是 一遍 扫描 不进行回溯
    for line in lines:
        line_dict = dict()
        line_dict['code'] = line
        line_dict['levels'] = []
        line_dict['ranges'] = []
        line_dict_list.append(line_dict)

    now_levels = ["bk"]
    now_ranges = [SOURCE_RANGE.COMMON]

    for line_dict in line_dict_list:
        # 如果是if开始
        if "if(" in line_dict["code"].replace(" ", "") and "endif" not in line_dict["code"]:

            now_levels.append("if")
            if "if(OB_BUILD_OPENSOURCE)" in line_dict["code"].replace(" ", ""):
                # 特殊 OB_BUILD_OPENSOURCE 逻辑开始
                now_ranges.append(SOURCE_RANGE.OPENSOURCE)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            elif "if(NOTOB_BUILD_OPENSOURCE)" in line_dict["code"].replace(" ", "") or "if(notOB_BUILD_OPENSOURCE)" in line_dict["code"].replace(" ", ""):
                # 特殊处理 OB_BUILD_OPENSOURCE 否定逻辑
                now_ranges.append(SOURCE_RANGE.BUSINESS)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            else:
                # 其他if逻辑
                now_ranges.append(SOURCE_RANGE.COMMON)
                line_dict['ranges'] = copy(now_ranges)

        elif "else()" in line_dict["code"]:
            # if层次pop出
            now_levels.pop()
            now_levels.append("else")

            # 根据if逻辑，切换逻辑
            latest_range = now_ranges.pop()
            if latest_range == SOURCE_RANGE.OPENSOURCE:
                now_ranges.append(SOURCE_RANGE.BUSINESS)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            elif latest_range == SOURCE_RANGE.BUSINESS:
                now_ranges.append(SOURCE_RANGE.OPENSOURCE)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            else:
                now_ranges.append(SOURCE_RANGE.COMMON)
                line_dict['ranges'] = copy(now_ranges)

        elif "endif()" in line_dict["code"]:
            now_levels.pop()

            latest_range = now_ranges.pop()
            if latest_range == SOURCE_RANGE.OPENSOURCE:
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            elif latest_range == SOURCE_RANGE.BUSINESS:
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            else:
                now_ranges.append(latest_range)
                line_dict['ranges'] = copy(now_ranges)
                now_ranges.pop()
        else:
            # 处理unity的情况
            if "ob_set_subtarget(" in line_dict["code"]:
                now_levels.append("unity")
                now_ranges.append(SOURCE_RANGE.COMMON)
                line_dict['ranges'] = copy(now_ranges)

            elif now_levels[-1] == "unity":
                if "OPENSOURCE:" in line_dict["code"]:
                    now_ranges.pop()
                    now_ranges.append(SOURCE_RANGE.OPENSOURCE)
                    line_dict['ranges'] = [SOURCE_RANGE.BORDER]
                elif "BUSINESS:" in line_dict["code"]:
                    now_ranges.pop()
                    now_ranges.append(SOURCE_RANGE.BUSINESS)
                    line_dict['ranges'] = [SOURCE_RANGE.BORDER]

                elif "COMMON:" in line_dict["code"]:
                    now_ranges.pop()
                    now_ranges.append(SOURCE_RANGE.COMMON)
                    line_dict['ranges'] = [SOURCE_RANGE.BORDER]
                elif ")" in line_dict["code"]:
                    now_levels.pop()
                    now_ranges.pop()
                    line_dict['ranges'] = copy(now_ranges)
                else:
                    line_dict['ranges'] = copy(now_ranges)
            else:
                # 其他情况，范围进行拷贝
                line_dict['ranges'] = copy(now_ranges)

        line_dict['levels'] = copy(now_levels)

    if GLOBAL_CONF.run_mode == RUN_MODE.SOURCE_DEBUG_MODE:
        for line_dict in line_dict_list:
            show_content = "|{:30}|{:30}|{:100}"
            print(show_content.format(" ".join(line_dict['levels']), " ".join(line_dict['ranges']), line_dict["code"].replace("\n", "")))

    # 如果不保存
    if GLOBAL_CONF.nosave:
        return

    opensource_need_files = []
    only_business_files = []

    touch_dir(cmake_opensource_src)

    file_line_list_temp = []
    for line_dict in line_dict_list:
        need_ok = True
        for one_range in line_dict['ranges']:
            if one_range == SOURCE_RANGE.BORDER:
                need_ok = False
                break
            if one_range == SOURCE_RANGE.BUSINESS:
                need_ok = False
                break
        if need_ok:
            file_line_list_temp.append(line_dict["code"])

            target_file = os.path.join(os.path.dirname(cmake_opensource_src), line_dict["code"].strip())
            if os.path.exists(target_file):
                opensource_need_files.append(target_file)
        else:
            # 从cmake中统计商业版本中 不需要的
            if SOURCE_RANGE.BORDER not in line_dict['ranges']:
                target_file = os.path.join(os.path.dirname(cmake_opensource_src), line_dict["code"].strip())
                if os.path.exists(target_file):
                    only_business_files.append(target_file)

    # 处理空的 ob_set_target()
    file_line_list_last = []
    need_jump = False
    for index in range(len(file_line_list_temp)):
        if "ob_set_subtarget(" in file_line_list_temp[index] and index + 1 < len(file_line_list_temp) and ")" in file_line_list_temp[index + 1]:
            need_jump = True
        else:
            if need_jump:
                need_jump = False
            else:
                file_line_list_last.append(file_line_list_temp[index])

    # 写入文件
    with open(cmake_opensource_src, "w") as fd:
        for one in file_line_list_last:
            fd.writelines(one)

    for one_business_file in only_business_files:
        if one_business_file not in opensource_need_files:
            cmake_del_files.append(one_business_file)

            # 跟随删除同名头文件
            #for suffix in (".cpp", ".c", ".cc"):
            #    if one_business_file.endswith(suffix):
            #        header_file = one_business_file.replace(suffix, ".h")
            #        if os.path.exists(header_file):
            #            cmake_del_files.append(header_file)


def handle_one_cpp_file(cpp_src, cpp_opensource_src = None):
    '''
    处理cpp文件
    '''
    global empty_del_files

    # 原来是否为空文件
    is_before_empty_file = True
    # 最终是否为空文件
    is_after_empty_file = True

    lines = None
    with open(cpp_src, "r") as fd:
        lines = fd.readlines()

    for line in lines:
        if line.strip():
            # 原来不是空文件
            is_before_empty_file = False
            break

    if not cpp_opensource_src:
        cpp_opensource_src = cpp_src

    line_dict_list = []
    # 本次算法都是 一遍 扫描 不进行回溯
    for line in lines:
        line_dict = dict()
        line_dict['code'] = line
        line_dict['levels'] = []
        line_dict['ranges'] = []
        line_dict_list.append(line_dict)

    now_levels = ["bk"]
    now_ranges = [SOURCE_RANGE.COMMON]

    for line_dict in line_dict_list:
        # 如果是if开始
        if "#ifdef" in line_dict["code"].replace(" ", "") or "#ifndef" in line_dict["code"].replace(" ", "") or "#if" in line_dict["code"].replace(" ", ""):
            now_levels.append("if")
            if "#ifdefOB_BUILD_OPENSOURCE" in line_dict["code"].replace(" ", ""):
                # 特殊处理 OB_BUILD_OPENSOURCE 逻辑开始
                now_ranges.append(SOURCE_RANGE.OPENSOURCE)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            elif "#ifndefOB_BUILD_OPENSOURCE" in line_dict["code"].replace(" ", ""):
                # 特殊处理 OB_BUILD_OPENSOURCE 否定逻辑
                now_ranges.append(SOURCE_RANGE.BUSINESS)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            else:
                # 其他if逻辑
                now_ranges.append(SOURCE_RANGE.COMMON)
                line_dict['ranges'] = copy(now_ranges)

        elif "#else" in line_dict["code"].replace(" ", ""):
            # if层次pop出
            now_levels.pop()
            now_levels.append("else")

            # 根据if逻辑，切换逻辑
            latest_range = now_ranges.pop()
            if latest_range == SOURCE_RANGE.OPENSOURCE:
                now_ranges.append(SOURCE_RANGE.BUSINESS)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            elif latest_range == SOURCE_RANGE.BUSINESS:
                now_ranges.append(SOURCE_RANGE.OPENSOURCE)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            else:
                now_ranges.append(SOURCE_RANGE.COMMON)
                line_dict['ranges'] = copy(now_ranges)

        elif "#endif" in line_dict["code"].replace(" ", ""):
            now_levels.pop()

            latest_range = now_ranges.pop()
            if latest_range == SOURCE_RANGE.OPENSOURCE:
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            elif latest_range == SOURCE_RANGE.BUSINESS:
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            else:
                now_ranges.append(latest_range)
                line_dict['ranges'] = copy(now_ranges)
                now_ranges.pop()
        else:
            # 其他情况，范围进行拷贝
            line_dict['ranges'] = copy(now_ranges)

        line_dict['levels'] = copy(now_levels)

    if GLOBAL_CONF.run_mode == RUN_MODE.SOURCE_DEBUG_MODE:
        for line_dict in line_dict_list:
            show_content = "|{:30}|{:30}|{:100}"
            print(show_content.format(" ".join(line_dict['levels']), " ".join(line_dict['ranges']), line_dict["code"].replace("\n", "")))

    # 如果不保存
    if GLOBAL_CONF.nosave:
        return

    # 保存文件
    touch_dir(cpp_opensource_src)
    with open(cpp_opensource_src, "w") as fd:
        for line_dict in line_dict_list:
            need_ok = True
            for one_range in line_dict['ranges']:
                if one_range == SOURCE_RANGE.BORDER:
                    need_ok = False
                    break
                if one_range == SOURCE_RANGE.BUSINESS:
                    need_ok = False
                    break
            if need_ok:
                fd.writelines(line_dict["code"])

                if is_after_empty_file and line_dict["code"].strip():
                    is_after_empty_file = False

    if not is_before_empty_file:
        if is_after_empty_file:
            empty_del_files.append(cpp_opensource_src)

def handle_one_note_file(file_src, file_opensource_src=None):
    '''
    处理note文件
    '''
    lines = None
    with open(file_src, "r") as fd:
        lines = fd.readlines()

    if not file_opensource_src:
        file_opensource_src = file_src

    line_dict_list = []
    # 本次算法都是 一遍 扫描 不进行回溯
    for line in lines:
        line_dict = dict()
        line_dict['code'] = line
        line_dict['levels'] = []
        line_dict['ranges'] = []
        line_dict_list.append(line_dict)

    now_levels = ["bk"]
    now_ranges = [SOURCE_RANGE.COMMON]

    # 有可能是[#](bash/python)，[//](cpp)
    note_prefix = ''

    for line_dict in line_dict_list:
        # 如果是if开始
        if "RANGE_IF" in line_dict["code"].replace(" ", ""):
            now_levels.append("start")
            if "RANGE_IF_OPENSOURCE" in line_dict["code"].replace(" ", ""):
                now_ranges.append(SOURCE_RANGE.OPENSOURCE)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            elif "RANGE_IF_BUSINESS" in line_dict["code"].replace(" ", ""):
                now_ranges.append(SOURCE_RANGE.BUSINESS)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            else:
                # 其他if逻辑
                now_ranges.append(SOURCE_RANGE.COMMON)
                line_dict['ranges'] = copy(now_ranges)

            # 寻找前缀
            if not note_prefix:
                note_prefix = line_dict["code"].split("RANGE_IF")[0]

        elif "RANGE_ELSE" in line_dict["code"].replace(" ", ""):
            # if层次pop出
            now_levels.pop()
            now_levels.append("else")

            # 根据if逻辑，切换逻辑
            latest_range = now_ranges.pop()
            if latest_range == SOURCE_RANGE.OPENSOURCE:
                now_ranges.append(SOURCE_RANGE.BUSINESS)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            elif latest_range == SOURCE_RANGE.BUSINESS:
                now_ranges.append(SOURCE_RANGE.OPENSOURCE)
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            else:
                now_ranges.append(SOURCE_RANGE.COMMON)
                line_dict['ranges'] = copy(now_ranges)

        elif "RANGE_END" in line_dict["code"].replace(" ", ""):
            now_levels.pop()

            latest_range = now_ranges.pop()
            if latest_range == SOURCE_RANGE.OPENSOURCE:
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            elif latest_range == SOURCE_RANGE.BUSINESS:
                line_dict['ranges'] = [SOURCE_RANGE.BORDER]
            else:
                now_ranges.append(latest_range)
                line_dict['ranges'] = copy(now_ranges)
                now_ranges.pop()
        else:
            # 其他情况，范围进行拷贝
            line_dict['ranges'] = copy(now_ranges)

        line_dict['levels'] = copy(now_levels)

    if GLOBAL_CONF.run_mode == RUN_MODE.SOURCE_DEBUG_MODE:
        for line_dict in line_dict_list:
            show_content = "|{:30}|{:30}|{:100}"
            print(show_content.format(" ".join(line_dict['levels']), " ".join(line_dict['ranges']), line_dict["code"].replace("\n", "")))

    # 如果不保存
    if GLOBAL_CONF.nosave:
        return

    # 保存文件
    touch_dir(file_opensource_src)
    with open(file_opensource_src, "w") as fd:
        for line_dict in line_dict_list:
            need_ok = True
            # 特殊标记是否是opensource，去掉前缀
            is_opensource = False
            for one_range in line_dict['ranges']:
                if one_range == SOURCE_RANGE.OPENSOURCE:
                    is_opensource = True

                if one_range == SOURCE_RANGE.BORDER:
                    need_ok = False
                    break
                if one_range == SOURCE_RANGE.BUSINESS:
                    need_ok = False
                    break

            if need_ok:
                if is_opensource and note_prefix:
                    if line_dict["code"].startswith(note_prefix):
                        fd.writelines(line_dict["code"][len(note_prefix):])
                else:
                    fd.writelines(line_dict["code"])

def load_sub_dir_file(dir_path):
    '''
    递归加载文件
    '''
    global all_source_files
    sub_files = []

    if not os.path.exists(dir_path):
        return []

    if os.path.isdir(dir_path):
        # 忽略一些文件
        for one_ignore in GLOBAL_CONF.ignore_suffix:
            if one_ignore in dir_path:
                return []
        # 传入文件夹
        lst = os.listdir(dir_path)
        for one_file in lst:
            if(os.path.isdir(os.path.join(dir_path, one_file))):
                sub_files.append({"type":'dir', "name": one_file, "base":dir_path, "sub": load_sub_dir_file(os.path.join(dir_path, one_file))})
            else:
                file_type_dict = {"type":'file', "name": one_file, "base":dir_path, "sub": []}
                sub_files.append(file_type_dict)
            # .git 不要
            if ".git" not in one_file:
                all_source_files.append(os.path.join(dir_path, one_file))
    else:
        # 传入文件
        return []

    return sub_files


def load_all_dir_file(dir_path):
    '''
    递归加载文件
    '''
    global source_del_files
    sub_files = []

    if not os.path.exists(dir_path):
        return []

    if os.path.isdir(dir_path):
        # 传入文件夹
        lst = os.listdir(dir_path)
        for one_file in lst:
            if(os.path.isdir(os.path.join(dir_path, one_file))):
                sub_files.append({"type":'dir', "name": one_file, "base":dir_path, "sub": load_all_dir_file(os.path.join(dir_path, one_file))})
            else:
                file_type_dict = {"type":'file', "name": one_file, "base":dir_path, "sub": []}
                sub_files.append(file_type_dict)
            source_del_files.append(os.path.join(dir_path, one_file))
    else:
        # 传入文件
        return []

    return sub_files

def is_suffix(file_name, suffix_list):
    '''
    判断文件后缀
    '''
    for one_suffix in suffix_list:
        if file_name.endswith(one_suffix):
            return True
    # 未匹配成功
    return False

def print_stage(str_stage):
    '''
    打印阶段
    '''
    all_len = 100
    str_len = len(str_stage.decode("utf-8"))
    padding = (all_len - str_len) / 2
    mat = "{:%d}{:%d}{:%d}" % (padding, str_len, padding)
    print_new_line()
    print_log(mat.format(">" * padding, str_stage, "<" * padding))

def global_exit(result):
    '''
    全局退出函数
    '''
    global final_result

    final_result['return_code'] = result['return_code']
    final_result['return_message'] = result['return_message']
    # 统计时间
    final_result["cost_time"] = get_cost_time()
    final_result["cost_time_ms"] = get_cost_time_ms()

    print_log("traceid: %s" % (GLOBAL_CONF.traceid))

    # 请求数据
    post_final_result()

    print_link_url()

    print_new_line()

    print_log("return code: %d, cost time: %s" %((result['return_code'], get_cost_time())))
    exit(result['return_code'])

def show_relative_path(path):
    '''
    显示相对路径
    '''
    return path.replace(GLOBAL_CONF.git_top_dir, "")

def init_workspace_stage():
    '''
    初始化工作目录
    '''
    global GLOBAL_CONF
    global ori_empty_dir_list
    global final_result
    stage_result = dict()
    stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
    stage_result["return_message"] = ""

    GLOBAL_CONF.cuurent_step_count += 1
    print_stage(" [stage %d/%d] 初始化构建环境" % (GLOBAL_CONF.cuurent_step_count, GLOBAL_CONF.total_step_count))
    print_log("函数:%s 行号:%d" % (sys._getframe().f_code.co_name, sys._getframe().f_lineno))
    time.sleep(1)

    need_check_file = True

    if GLOBAL_CONF.run_mode == RUN_MODE.SOURCE_DEBUG_MODE:
        # 调试模式不检查
        need_check_file = False

    # 获取根目录
    result = shell_run_command("git rev-parse --show-toplevel 2>/dev/null")
    if result['return_code'] != 0:
        print_log("[ERROR] 初始化工作目录失败，您当前不在git目录，请在OB的git目录运行")
        global_exit(stage_result)

    GLOBAL_CONF.git_top_dir = result['return_message'][0].strip()

    if need_check_file:
        # 当前工程不运行有git diff和未提交文件，否则退出
        print_log("开始检查当前目录是否存在uncommit文件")
        result = shell_run_command("cd %s && git diff HEAD --name-only" % (GLOBAL_CONF.git_top_dir))
        if result['return_code'] != ERROR_CODE.COMMON_SUCCESS:
            print_log("[WARNING] 运行git diff HEAD --name-only命令失败，请检查git目录是否完整")
            stage_result["return_message"] = "failed to [run git diff HEAD --name-only]"
            global_exit(stage_result)

        if type(result["return_message"]) == list:
            for one_diff_file in result["return_message"]:
                one_diff_file = one_diff_file.strip()
                print_log("开始二次校验文件[%s]是否修改" %one_diff_file)
                if os.path.exists(os.path.join(GLOBAL_CONF.git_top_dir, one_diff_file)):
                    stage_result['return_message'] = "exist uncommit files"
                    print_log("[ERROR] 您的工程下面有未提交文件，当前[%s]下，防止源码丢失不允许进行开源裁剪，请commit后重试" % GLOBAL_CONF.run_mode)
                    global_exit(stage_result)

        print_log("判断当前工程是否存在.4_ce")
        if not os.path.isfile(os.path.join(GLOBAL_CONF.git_top_dir, ".4_ce")):
            stage_result['return_message'] = "not exist .4_ce"
            print_log("[ERROR] 当前工程不存在[.4_ce]文件，判定为不属于4.0开源代码项目，无法进行裁剪" % GLOBAL_CONF.run_mode)
            global_exit(stage_result)

    # 获取commit信息
    print_log("获取commit提交信息:")
    result = shell_run_command("git rev-parse HEAD")
    if result['return_code'] != 0:
        print_log("[ERROR] 获取commit基础信息失败")
        stage_result["return_message"] = "failed to get commit info"
        global_exit(stage_result)
    final_result["commitid"] = result['return_message'][0].strip()

    result = shell_run_command("git show -s %s --pretty=format:'<%%an> (%%ci) %%d %%s'" % final_result["commitid"])
    if result['return_code'] != 0:
        print_log("[ERROR] 获取commit基础信息失败")
        stage_result["return_message"] = "failed to get commit info"
        global_exit(stage_result)
    final_result["commit_info"] = result['return_message'][0].strip()

    print_log("开始递归当前文件夹所有文件")
    load_sub_dir_file(GLOBAL_CONF.git_top_dir)
    print_log("所有文件个数: %d" % len(all_source_files))

    # 记录原来是空文件
    for one in all_source_files:
        if os.path.isdir(one):
            if not os.listdir(one):
                ori_empty_dir_list.append(one)

def del_close_sources_file_stage():
    '''
    删除CLOSE_SOURCES文件
    '''
    global source_del_files
    global all_source_files
    stage_result = dict()
    stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
    stage_result["return_message"] = ""

    GLOBAL_CONF.cuurent_step_count += 1
    print_stage(" [stage %d/%d] 根据CLOSE_SOURCES删除非开源代码" % (GLOBAL_CONF.cuurent_step_count, GLOBAL_CONF.total_step_count))
    print_log("函数:%s 行号:%d" % (sys._getframe().f_code.co_name, sys._getframe().f_lineno))
    time.sleep(1)

    CLOSE_SOURCES_file_path = os.path.join(GLOBAL_CONF.git_top_dir, "CLOSE_SOURCES")

    if not os.path.isfile(CLOSE_SOURCES_file_path):
        print_log("%s不存在，请提供该文件" % CLOSE_SOURCES_file_path)
        global_exit(stage_result)

    lines = []
    with open(CLOSE_SOURCES_file_path, "r") as fd:
        lines = fd.readlines()

    close_sources_file_list = []
    for line in lines:
        line = line.strip()
        if line:
            # 不处理注释
            if "#" not in line:
                close_sources_file_list.append(line)
            else:
                line_array = line.split("#")
                if line_array and line_array[0]:
                    close_sources_file_list.append(line_array[0])

    for one_business in close_sources_file_list:
        absolute_path = os.path.join(GLOBAL_CONF.git_top_dir, one_business)
        if "**" in absolute_path:
            if os.path.isdir(absolute_path.replace("**", "")):
                source_del_files.append(absolute_path.replace("**", ""))

            p = absolute_path.replace(".", "\.").replace("**", ".*")
            for one_all_file in all_source_files:
                result = re.match(p, one_all_file)
                if result:
                    source_del_files.append(one_all_file)

        elif "*" in absolute_path:
            if os.path.isdir(absolute_path.replace("*", "")):
                source_del_files.append(absolute_path.replace("*", ""))

            p = absolute_path.replace(".", "\.").replace("*", ".*")
            for one_all_file in all_source_files:

                result = re.match(p, one_all_file)
                if result:
                    # * 需要层级匹配
                    if len(one_all_file.split("/")) == len(absolute_path.split("/")):
                        source_del_files.append(one_all_file)
        else:
            if os.path.exists(absolute_path):
                if os.path.isfile(absolute_path):
                    source_del_files.append(absolute_path)
                else:
                    load_all_dir_file(absolute_path)

    # 先删除文件夹
    print_log("开始删除文件夹")
    del_dir_count = 0
    for one in source_del_files:
        if os.path.exists(one):
            if os.path.isdir(one):
                del_dir_count += 1
                print_log("开始删除文件夹: %d. %s" % (del_dir_count, one))
                shutil.rmtree(one)

    # 再删除文件
    del_file_count = 0
    print_log("开始删除文件")
    for one in source_del_files:
        if os.path.exists(one):
            del_file_count += 1
            print_log("开始删除文件: %d. %s" % (del_file_count ,one))
            os.remove(one)

def replace_opensource_file_stage():
    '''
    替换.opensource后缀文件
    例如存在 readme.txt readme.txt.opensource 文件
    会执行
    mv readme.txt.opensource readme.txt
    '''
    stage_result = dict()
    stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
    stage_result["return_message"] = ""

    GLOBAL_CONF.cuurent_step_count += 1
    print_stage(" [stage %d/%d] 替换.opensource后缀文件" % (GLOBAL_CONF.cuurent_step_count, GLOBAL_CONF.total_step_count))
    print_log("函数:%s 行号:%d" % (sys._getframe().f_code.co_name, sys._getframe().f_lineno))
    time.sleep(1)

    print_log("开始替换开源文件")
    repalce_count = 0
    for one in all_source_files:
        if is_suffix(one, (".opensource",)) and os.path.exists(one):
            file_opensource_suffix = one
            file_last = one.replace(".opensource", "")
            repalce_count += 1
            print_log("替换文件 %d. %s -> %s" % (repalce_count, file_opensource_suffix, file_last))
            shell_run_command("rm -rf %s && mv %s %s" % (file_last, file_opensource_suffix, file_last))

def del_cmake_files_stage():
    '''
    删除cmake中BUSINESS类型文件
    '''
    stage_result = dict()
    stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
    stage_result["return_message"] = ""

    GLOBAL_CONF.cuurent_step_count += 1
    print_stage(" [stage %d/%d] 删除cmake中BUSINESS类型文件阶段" % (GLOBAL_CONF.cuurent_step_count, GLOBAL_CONF.total_step_count))
    print_log("函数:%s 行号:%d" % (sys._getframe().f_code.co_name, sys._getframe().f_lineno))
    time.sleep(1)

    del_count = 0
    for one in cmake_del_files:
        if os.path.exists(one):
            del_count += 1
            print_log("开始删除文件: %d. %s" % (del_count ,one))
            os.remove(one)

def del_empty_files_stage():
    '''
    删除空文件，例如头文件中的大宏
    '''
    stage_result = dict()
    stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
    stage_result["return_message"] = ""

    GLOBAL_CONF.cuurent_step_count += 1
    print_stage(" [stage %d/%d] 删除删除空文件和文件夹阶段" % (GLOBAL_CONF.cuurent_step_count, GLOBAL_CONF.total_step_count))
    print_log("函数:%s 行号:%d" % (sys._getframe().f_code.co_name, sys._getframe().f_lineno))
    time.sleep(1)

    del_count = 0
    print_log("开始删除空文件(裁剪之前非空)")
    for one in empty_del_files:
        if os.path.exists(one):
            del_count += 1
            print_log("删除空文件: %d. %s" % (del_count, one))
            os.remove(one)

    print_log("开始删除空文件夹(裁剪之前非空)")
    for one in all_source_files:
        if os.path.isdir(one):
            if not os.listdir(one) and one not in ori_empty_dir_list:
                del_count += 1
                print_log("删除空文件夹: %d. %s" % (del_count, one))
                os.rmdir(one)

def handle_note_files_stage():
    '''
    执行note类型裁剪
    '''
    global all_source_files

    stage_result = dict()
    stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
    stage_result["return_message"] = ""

    GLOBAL_CONF.cuurent_step_count += 1
    print_stage(" [stage %d/%d] Note类型裁剪阶段" % (GLOBAL_CONF.cuurent_step_count, GLOBAL_CONF.total_step_count))
    print_log("函数:%s 行号:%d" % (sys._getframe().f_code.co_name, sys._getframe().f_lineno))
    time.sleep(1)

    all_need_files = []

    for one_file in all_source_files:
        # 处理文件的注释
        if not os.path.isfile(one_file):
            continue

        if not is_suffix(one_file, GLOBAL_CONF.note_type_suffix):
            continue

        all_need_files.append(one_file)

    for cur_index, one_file in enumerate(all_need_files):
        print_log("%d/%d %.2f%% Note类型裁剪 %s" % (cur_index,  len(all_need_files), 100 * div_operator(cur_index, len(all_need_files)), one_file))
        handle_one_note_file(one_file)

def handle_cmake_files_stage():
    '''
    处理cmake文件
    '''
    global all_source_files
    global GLOBAL_CONF

    stage_result = dict()
    stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
    stage_result["return_message"] = ""

    GLOBAL_CONF.cuurent_step_count += 1
    print_stage(" [stage %d/%d] cmake类型裁剪阶段" % (GLOBAL_CONF.cuurent_step_count, GLOBAL_CONF.total_step_count))
    print_log("函数:%s 行号:%d" % (sys._getframe().f_code.co_name, sys._getframe().f_lineno))
    time.sleep(1)

    all_need_files = []

    for one_file in all_source_files:
        # 处理文件的注释
        if not os.path.isfile(one_file):
            continue
        if is_suffix(one_file, GLOBAL_CONF.cmake_type_suffix):
            all_need_files.append(one_file)

    for cur_index, one_file in enumerate(all_need_files):
        print_log("%d/%d cmake类型裁剪 %.2f%% %s" % (cur_index,  len(all_need_files), 100 * div_operator(cur_index, len(all_need_files)), one_file))
        handle_one_cmake_file(one_file)

def handle_cpp_files_stage():
    '''
    处理cpp文件
    '''
    global all_source_files

    GLOBAL_CONF.cuurent_step_count += 1
    print_stage(" [stage %d/%d] cpp类型裁剪阶段" % (GLOBAL_CONF.cuurent_step_count, GLOBAL_CONF.total_step_count))
    print_log("函数:%s 行号:%d" % (sys._getframe().f_code.co_name, sys._getframe().f_lineno))
    time.sleep(1)

    stage_result = dict()
    stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
    stage_result["return_message"] = ""

    all_need_files = []

    for one_file in all_source_files:
        # 处理文件的注释
        if not os.path.isfile(one_file):
            continue

        if is_suffix(one_file, GLOBAL_CONF.cpp_type_suffix):
            all_need_files.append(one_file)

    for cur_index, one_file in enumerate(all_need_files):
        print_log("%d/%d cpp类型裁剪 %.2f%% %s" % (cur_index,  len(all_need_files), 100 * div_operator(cur_index, len(all_need_files)), one_file))
        handle_one_cpp_file(one_file)

def run_strip_mode():
    '''
    裁剪模式
    '''
    global GLOBAL_CONF

    mode_result = dict()
    mode_result["return_code"] = ERROR_CODE.COMMON_ERROR
    mode_result["return_message"] = ""

    GLOBAL_CONF.total_step_count = 8

    # 初始化工程
    init_workspace_stage()

    # 根据CLOSE_SOURCES删除文件
    del_close_sources_file_stage()

    # 替换.opensource后缀文件
    replace_opensource_file_stage()

    # 删除注释
    handle_note_files_stage()

    # 核心文本裁剪：处理cmake文件
    handle_cmake_files_stage()

    # 核心文本裁剪：处理cpp源文件
    handle_cpp_files_stage()

    # 删除cmake中不需要的cpp文件
    del_cmake_files_stage()

    # 删除cpp宏定义处理后的空文件
    del_empty_files_stage()

    print_new_line()
    print_log("裁剪成功！这将是一份用于开源的代码了!")
    print_new_line()

    mode_result["return_code"] = ERROR_CODE.COMMON_SUCCESS
    mode_result["return_message"] = "strip success"
    global_exit(mode_result)

def trigger_one_build(one_compile):
    '''
    触发一个编译任务
    '''
    global GLOBAL_CONF
    global GLBOAL_STOP_FLAG
    global GLOBAL_CUR_COUNT
    global GLOBAL_ALL_COUNT
    # 通过semaphore限制并发数
    GLOBAL_CONF.semaphore.acquire()
    if not GLBOAL_STOP_FLAG:
        cpp_file = get_flag(one_compile, "-c")
        workspace = one_compile.split("&&")[0].replace("cd", "").strip()
        md_file = get_flag(one_compile, "-MF")

        pre_one_compile = one_compile.strip().replace(" -c ", " -E ").replace(" -MD ", " -MMD ")

        result = shell_run_command(pre_one_compile, need_print_all=False)

        GLBOAL_PROCESS_LOCK.acquire()

        GLOBAL_CUR_COUNT += 1
        print_log("%d/%d %.2f%% 收集所需文件 %s" % (GLOBAL_CUR_COUNT, GLOBAL_ALL_COUNT, 100 * div_operator(GLOBAL_CUR_COUNT, GLOBAL_ALL_COUNT), get_flag(one_compile, "-c")))
        md_file_path = os.path.join(workspace, md_file)
        file_lines = None
        with open(md_file_path, "r") as fd:
            file_lines = fd.readlines()

        for one in file_lines:
            one = one.strip()
            if ": " in one:
                one = one.split(":")[1]

            cpp_file = one.replace("\\", "").strip()

            # 一行可能包含多个文件，空格分隔
            cpp_file_oneline_list = []
            if " " in cpp_file:
                cpp_file_oneline_list.extend(cpp_file.split(" "))
            else:
                cpp_file_oneline_list.append(cpp_file)

            for one_cpp_file in cpp_file_oneline_list:
                if not one_cpp_file.strip():
                    continue
                # 过滤目录
                if "/deps/3rd/" in one_cpp_file:
                    continue
                if  "/build_debug" in one_cpp_file:
                    continue

                if one_cpp_file not in all_need_cpp_file_list:
                    all_need_cpp_file_list.append(one_cpp_file)
        GLBOAL_PROCESS_LOCK.release()

    GLOBAL_CONF.semaphore.release()

def collect_need_files_stage():
    '''
    收集所有编译文件阶段
    '''
    global all_need_cpp_file_list
    global GLOBAL_ALL_COUNT

    stage_result = dict()
    stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
    stage_result["return_message"] = ""

    GLOBAL_CONF.cuurent_step_count += 1
    print_stage(" [stage %d/%d] 收集所有编译文件阶段" % (GLOBAL_CONF.cuurent_step_count, GLOBAL_CONF.total_step_count))
    print_log("函数:%s 行号:%d" % (sys._getframe().f_code.co_name, sys._getframe().f_lineno))
    time.sleep(1)

    result = shell_run_command("cd %s && rm -rf build_debug && sh build.sh debug --ce --init" % (GLOBAL_CONF.git_top_dir))
    if result["return_code"] != ERROR_CODE.COMMON_SUCCESS:
        print_log(result['return_message'])
        print_log("[ERROR] 运行编译依赖初始化失败")
        global_exit(stage_result)

    result = shell_run_command("cd %s/build_debug && make observer --just-print --ignore-errors" % (GLOBAL_CONF.git_top_dir), need_print_output=False)
    if result["return_code"] != ERROR_CODE.COMMON_SUCCESS:
        print_log(result['return_message'])
        print_log("[ERROR] 生成编译命令失败")
        global_exit(stage_result)

    all_compile_command_list = result['return_message']
    real_compile_command_list = []
    for one_compile in all_compile_command_list:
        # 仅测试编译阶段
        if " -c " not in one_compile:
            continue
        if ".S" in one_compile:
            continue

        real_compile_command_list.append(one_compile)

    print_log("开始预处理")
    GLOBAL_ALL_COUNT = len(real_compile_command_list)
    thread_list = list()
    for one_compile in real_compile_command_list:
        t = threading.Thread(target=trigger_one_build,args=(one_compile, ))
        thread_list.append(t)
        t.start()

    # 等待并发结束
    for t in thread_list:
        t.join()

def check_need_files_stage():
    '''
    最后检查文件情况
    '''
    global all_need_cpp_file_list
    global final_result

    stage_result = dict()
    stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
    stage_result["return_message"] = ""

    GLOBAL_CONF.cuurent_step_count += 1
    print_stage(" [stage %d/%d] 收集所有编译文件阶段" % (GLOBAL_CONF.cuurent_step_count, GLOBAL_CONF.total_step_count))
    print_log("函数:%s 行号:%d" % (sys._getframe().f_code.co_name, sys._getframe().f_lineno))
    time.sleep(1)

    print_log("开始检查编译所需的文件丢失情况")
    miss_count = 0
    for one in all_need_cpp_file_list:
        if not os.path.exists(one):
            miss_count += 1
            print_log("编译所需文件已丢失 %d. %s " % (miss_count, one))

    # 恢复代码变更
    if GLOBAL_CONF.nosave:
        print_new_line()
        print_log("开始恢复代码")
        shell_run_command("cd %s && git checkout ." % (GLOBAL_CONF.git_top_dir))

    final_result["all_need_file_count"] = len(all_need_cpp_file_list)
    final_result["miss_file_count"] = miss_count

    print_new_line()
    if miss_count > 0:
        print_log("[ERROR]总共编译所需%d个文件，丢失文件%d个，丢失率%.2f%%，请检查相关规则文件" % (len(all_need_cpp_file_list), miss_count, 100 * div_operator(miss_count, len(all_need_cpp_file_list))))
        stage_result["return_message"] = "check %d files miss" % miss_count
        stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
        print_new_line()
        print_log("若在farm上失败，如何本地复现: 在根目录运行 ./%s --check" % GLOBAL_CONF.tool_bin)
        print_new_line()
        global_exit(stage_result)
    else:
        print_log("总共总共编译所需%d个文件均存在" % (len(all_need_cpp_file_list)))

    # 测试跑一把 生成cmake文件
    print_log("开始最后测试生成makefile能否成功")
    result = shell_run_command("cd %s && sh build.sh clean && sh build.sh --init" % (GLOBAL_CONF.git_top_dir))
    if result["return_code"] != ERROR_CODE.COMMON_SUCCESS:
        print_log("[ERROR] 检查失败，生成Makefile不成功，将根据日志检查文件情况")
        stage_result["return_message"] = "generate Makefile failed"
        stage_result["return_code"] = ERROR_CODE.COMMON_ERROR
        print_new_line()
        print_log("若在farm上失败，如何本地复现: 在根目录运行 ./%s --check" % GLOBAL_CONF.tool_bin)
        print_new_line()
        global_exit(stage_result)

def run_check_mode():
    '''
    检查模式
    '''
    global GLOBAL_CONF
    global all_source_files

    mode_result = dict()
    mode_result["return_code"] = ERROR_CODE.COMMON_ERROR
    mode_result["return_message"] = ""

    GLOBAL_CONF.total_step_count = 10

    # 初始化
    init_workspace_stage()

    # 收集所有文件
    collect_need_files_stage()

    # 根据CLOSE_SOURCES删除文件
    del_close_sources_file_stage()

    # 替换.opensource后缀文件
    replace_opensource_file_stage()

    # 删除注释
    handle_note_files_stage()

    # 核心文本裁剪：处理cmake文件
    handle_cmake_files_stage()

    # 核心文本裁剪：处理cpp源文件
    handle_cpp_files_stage()

    # 删除cmake中不需要的cpp文件
    del_cmake_files_stage()

    # 删除cpp宏定义处理后的空文件
    del_empty_files_stage()

    # 最后检查文件情况
    check_need_files_stage()

    print_log("检查成功! 编译所有文件都未丢失")

    print_new_line()

    mode_result["return_code"] = ERROR_CODE.COMMON_SUCCESS
    global_exit(mode_result)

def source_debug_mode():
    '''
    源码调试模式
    '''
    global GLOBAL_CONF
    global all_source_files

    mode_result = dict()
    mode_result["return_code"] = ERROR_CODE.COMMON_ERROR
    mode_result["return_message"] = ""

    GLOBAL_CONF.total_step_count = 3

    init_workspace_stage()

    debug_count = 0

    if "./" in GLOBAL_CONF.debug_source:
        GLOBAL_CONF.debug_source = GLOBAL_CONF.debug_source.replace("./", GLOBAL_CONF.git_top_dir + "/")

    for one in all_source_files:
        if one.endswith(GLOBAL_CONF.debug_source):
            debug_count += 1
            current_type = GLOBAL_CONF.debug_type
            if not current_type:
                if is_suffix(one, GLOBAL_CONF.cmake_type_suffix):
                    current_type = TEXT_STRIP_TYPE.CMAKE_MODE
                elif is_suffix(one, GLOBAL_CONF.cpp_type_suffix):
                    current_type = TEXT_STRIP_TYPE.CPP_MODE
                elif is_suffix(one, GLOBAL_CONF.note_type_suffix):
                    current_type = TEXT_STRIP_TYPE.NOTE_MODE
                else:
                    print_log("未知类型，按照note类型，%s" % one)
                    current_type = TEXT_STRIP_TYPE.NOTE_MODE

            print_new_line()
            print_log("%s %d. %s" % (current_type, debug_count, one))
            if current_type == TEXT_STRIP_TYPE.CMAKE_MODE:
                handle_one_cmake_file(one)
            elif current_type == TEXT_STRIP_TYPE.CPP_MODE:
                handle_one_cpp_file(one)
            elif current_type == TEXT_STRIP_TYPE.NOTE_MODE:
                handle_one_note_file(one)

    mode_result['return_message'] = "debug source: %s" % (GLOBAL_CONF.debug_source)
    if debug_count == 0:
        print_log("[ERROR] 输入的条件[%s]，没有找到匹配到任何源文件，请重试" % (GLOBAL_CONF.debug_source))
    else:
        mode_result["return_code"] = ERROR_CODE.COMMON_SUCCESS

    global_exit(mode_result)

def post_final_result():
    '''
    保存结果数据，用于hook数据
    '''
    global final_result
    global GLOBAL_CONF

    # 替换username为git用户
    if not final_result['username']:
        final_result['username'] =  final_result['commit_info'].split('>')[0].replace("<", "")

    # 填充username为空的情况
    if not final_result['hostname']:
        final_result['hostname'] = socket.gethostname()

    result_json_file_path = "%s/strip2ce_result.json" % GLOBAL_CONF.git_top_dir

    save_result = write_json_file(result_json_file_path, final_result)
    if save_result['return_code'] != ERROR_CODE.COMMON_SUCCESS:
        print_log("[WARNING] failed to genreate result.json")
        return

    # 发送请求到后端
    result = shell_run_command("curl -X 'POST' '%s/strip2ce/send/%s/' -H 'accept: application/json' -H 'Content-Type: multipart/form-data' -F 'file=@%s;type=application/json' "
                % (GLOBAL_CONF.api_url, GLOBAL_CONF.traceid, result_json_file_path), need_print_all=False)

    if result["return_code"] != ERROR_CODE.COMMON_SUCCESS:
        print_log("[WARNING] failed to post data to backend")

    # 删除json文件
    shell_run_command("rm -rf %s" % result_json_file_path, need_print_all=False)

def main():
    '''
    main函数入口
    '''
    global GLOBAL_CONF
    global final_result

    # 初始化返回结果
    final_result['return_code'] = ERROR_CODE.COMMON_ERROR
    final_result['return_message'] = ""
    final_result['traceid'] = GLOBAL_CONF.traceid
    final_result['username'] = os.getenv("USER")
    final_result["hostname"] = os.getenv("HOSTNAME")
    final_result["commitid"] = ""
    final_result["commit_info"] = ""
    # check mode field
    # 所有需要的文件
    final_result['all_need_file_count'] = 0
    # 丢失文件
    final_result['miss_file_count'] = 0

    print_bar()

    parse_arg()

    # 平滑退出
    signal.signal(signal.SIGINT, ctrl_c_handler)

    print_log("欢迎使用[%s] 版本V%s build%s @%s" % (GLOBAL_CONF.tool_name, \
                                            GLOBAL_CONF.version, \
                                            GLOBAL_CONF.buildtime, \
                                            GLOBAL_CONF.auther))

    print_log("当前运行模式: [%s]" % GLOBAL_CONF.run_mode)

    final_result['run_mode'] = GLOBAL_CONF.run_mode

    if GLOBAL_CONF.run_mode == RUN_MODE.STRIP_MODE:
        run_strip_mode()
    elif GLOBAL_CONF.run_mode == RUN_MODE.CHECK_MODE:
        run_check_mode()
    elif GLOBAL_CONF.run_mode == RUN_MODE.SOURCE_DEBUG_MODE:
        source_debug_mode()
    else:
        pass

if __name__ == '__main__':
    '''
    __main__入口
    '''
    main()
