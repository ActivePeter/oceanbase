/**
 * Copyright (c) 2021 OceanBase
 * OceanBase CE is licensed under Mulan PubL v2.
 * You can use this software according to the terms and conditions of the Mulan PubL v2.
 * You may obtain a copy of Mulan PubL v2 at:
 *          http://license.coscl.org.cn/MulanPubL-2.0
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
 * MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
 * See the Mulan PubL v2 for more details.
 */

#ifndef OCEANBASE_SRC_PL_OB_PL_COMMAND_H_
#define OCEANBASE_SRC_PL_OB_PL_COMMAND_H_


#include "lib/string/ob_string.h"
#include "lib/string/ob_sql_string.h"
#include "common/ob_queue_thread.h"
#include "common/object/ob_object.h"

namespace oceanbase
{
namespace pl
{
namespace debugger
{

enum class ObPLCommandType
{
  invalid_type,
  print_backtrace,
  print_backtrace_v2,
  continue_execution,
  breakpoint_at_line,
  breakpoint_at_function,
  breakpoint_delete,
  breakpoint_disable,
  breakpoint_enable,
  breakpoint_show,
  read_value,
  read_values
};

enum class ObPLBreakFlag
{
  break_none        = 0,
  // Break when an exception is raised.
  break_exception   = 2,
  // Break at next source line (step into calls).
  break_any_call    = 12,
  // Break the next time an entrypoint gets ready to return.
  // (This includes entrypoints called from the current one.
  // If interpreter is running Proc1, which calls Proc2,
  // then break_return stops at the end of Proc2.)
  break_return      = 16,
  // Break at next source line (step over calls).
  break_next_line   = 32,
  // Break after returning from current entrypoint
  // (skip over any entrypoints called from the current routine).
  break_any_return  = 512,
  // Break when an exception handler is executed.
  break_handler     = 2048,
  // Stop execution and force an 'exit' event as soon as DBMS_DEBUG.CONTINUE is called.
  abort_execution   = 8192,
};

enum class ObPLTimeoutBehaviour
{
  // Retry. Timeout has no effect. This is like setting the timeout to an infinitely large value.
  retry_on_timeout = 0,
  // Continue execution, using same event flags.
  continue_on_timeout = 1,
  // Turn debug-mode OFF (in other words, call debug_off) and then continue execution.
  // No more events will be generated by this target session
  // unless it is re-initialized by calling debug_on.
  nodebug_on_timeout = 2,
  // Continue execution, using the abort_execution flag,
  // which should cause the program to terminate immediately.
  // The session remains in debug-mode.
  abort_on_timeout = 3,
};

union ObPLCommandInfo
{
  ObPLCommandInfo() { reset(); }

  common::ObString func_;          // breakpoint_at_function
  int line_;                       // breakpoint_at_line
  int number_;                     // breakpoint_delete/enable/disable
  ObPLBreakFlag breakflag_;        // continue_target

  // read value
  common::ObString value_name_;    // value_name
  char *format_;                   // value_format
  int frame_;                      // frame

  inline void reset()
  {
    func_.reset();
    line_ = -1;
    number_ = -1;
    breakflag_ = ObPLBreakFlag::break_none;
    value_name_.reset();
    format_ = NULL;
    frame_ = -1;
  }

  inline void set_breakflag(ObPLBreakFlag breakflag) { breakflag_ = breakflag; }
  inline void set_func(common::ObString &func) { func_ = func; }
  inline void set_line(int line) { line_ = line; }
  inline void set_number(int number) { number_ = number; }
  inline void set_name(common::ObString &name) { value_name_ = name; }
  inline void set_frame(int frame) { frame_ = frame; }

  inline ObPLBreakFlag get_breakflag() const { return breakflag_; }
  inline const common::ObString& get_func() const { return func_; }
  inline int get_line() const { return line_; }
  inline int get_number() const { return number_; }
  inline const common::ObString& get_name() const { return value_name_; }
  inline int get_frame() const { return frame_; }

  TO_STRING_KV(K(func_), K_(line), K_(number), K_(breakflag), K_(value_name), K_(frame));
};

struct ObPLCommandResult
{
public:
  ObPLCommandResult() { reset(); }

  inline void set_ret(int ret) { ret_ = ret; }
  inline void set_number(int number) { number_ = number; }

  inline int get_ret() { return ret_; }
  inline int get_number() { return number_; }
  inline common::ObSqlString& get_backtrace() { return backtrace_; }
  inline common::ObObj& get_backtrace_v2() { return backtrace_v2_; }
  inline common::ObSqlString& get_breakpoints() { return breakpoints_; }
  inline common::ObSqlString& get_scalar_value() { return scalar_value_; }
  inline common::ObObj& get_runtime_info() { return runtime_info_; }

  inline void reset()
  {
    ret_ = common::OB_SUCCESS;
    number_ = -1;
    backtrace_.reset();
    breakpoints_.reset();
    scalar_value_.reset();
    runtime_info_.reset();
  }

  TO_STRING_KV(
    K_(ret), K_(number), K_(backtrace), K_(breakpoints), K_(scalar_value));

private:
  int ret_;                           // OB_SUCCESS or not OB_SUCCESS
  int number_;                        // breakpoint_at_line/function
  common::ObSqlString backtrace_;     // print_backtrace
  common::ObSqlString breakpoints_;   // breakpoint_show
  common::ObSqlString scalar_value_;  // read_value/read_values
  common::ObObj runtime_info_;        // runtime_info
  common::ObObj backtrace_v2_;        // print_backtrace_v2
};

class ObPLCommand
{
public:
  ObPLCommand()
    : type_(ObPLCommandType::invalid_type),
      info_(),
      result_() {}

  inline void set_type(ObPLCommandType type) { info_.reset(); type_ = type; }

  inline ObPLCommandType get_type() { return type_; }
  inline ObPLCommandInfo& get_info() { return info_; }
  inline ObPLCommandResult& get_result() { return result_; }

  inline void reset()
  {
    type_ = ObPLCommandType::invalid_type;
    info_.reset();
    result_.reset();
  }

  TO_STRING_KV(K_(type), K_(info), K_(result));

private:
  ObPLCommandType type_;
  ObPLCommandInfo info_;
  ObPLCommandResult result_;
};

class ObPLIDWARFHelper
{
public:
  ObPLIDWARFHelper() {}
  ~ObPLIDWARFHelper() {}
  TO_STRING_EMPTY();
};

}
}
}

#endif // OCEANBASE_SRC_PL_OB_PL_COMMAND_H_
